import os
os.environ['KMP_DUPLICATE_LIB_OK']='True'
import math
from set_initial_solution_next import *
import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
import numpy as np
from gurobipy import *
import time
from MT_para_real import *
from scipy.spatial.distance import euclidean
import torch
import torch.nn as nn
import torch.nn.functional as F
import networkx as nx

# 导入我们的EGCN实现和训练器
from egcn_o import EGCN
from egcn_trainer import EGCNTrainer
import utils as u

# =========================================================================
# ============= EGCN初始化部分 ===============================================
# =========================================================================

# 初始化EGCN训练器和模型
print("正在初始化EGCN模型...")
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

egcn_trainer = EGCNTrainer(device=device)

# 尝试加载预训练模型，如果不存在则使用未训练的模型
model_path = 'PP+ML/egcn_trained_model.pth'
if os.path.exists(model_path):
    print(f"发现预训练模型，正在加载: {model_path}")
    egcn_trainer.load_model(model_path)
    print("✅ 预训练模型加载成功")
else:
    print("⚠️  未发现预训练模型，使用随机初始化的模型")
    print("建议先运行 egcn_trainer.py 进行训练")

egcn_model = egcn_trainer.model
egcn_classifier = egcn_trainer.classifier

# EGCN相关参数
REDUNDANCY_THRESHOLD = 0.95  # 论文中的阈值
all_column_features = []     # 存储所有列的特征
all_column_embeddings = None # 存储所有列的嵌入

print(f"EGCN模型已初始化，使用设备: {device}")

def extract_column_features(coal_quantities, time_overlap, vessel_count):
    """
    从列信息中提取特征向量
    
    Args:
        coal_quantities: (N_num,) 各种煤炭的采购量
        time_overlap: (T_num,) 各时刻的泊位占用情况  
        vessel_count: 标量，使用的船只数量
        
    Returns:
        feature_vector: (N_num + T_num + 1,) 特征向量
    """
    coal_quantities = np.array(coal_quantities)
    time_overlap = np.array(time_overlap) 
    vessel_count = np.array([vessel_count])
    
    feature_vector = np.concatenate([coal_quantities, time_overlap, vessel_count])
    return feature_vector

def egcn_redundancy_check(new_column_features):
    """
    使用训练好的EGCN检查新列是否冗余
    
    Args:
        new_column_features: 新列的特征向量
        
    Returns:
        is_redundant: bool, 是否冗余
        redundancy_info: dict, 冗余信息
    """
    global all_column_features, all_column_embeddings
    
    if len(all_column_features) == 0:
        return False, {'max_probability': 0.0, 'redundant_with': None}
    
    # 使用训练器的评估方法
    with torch.no_grad():
        egcn_model.eval()
        egcn_classifier.eval()
        
        # 准备输入数据
        all_features = all_column_features + [new_column_features]
        features = torch.tensor(np.array(all_features), dtype=torch.float32, device=device)
        
        # 构建邻接矩阵
        adj_matrices = egcn_trainer.generate_adjacency_matrices(features)
        for rel_type in adj_matrices:
            adj_matrices[rel_type] = adj_matrices[rel_type].to(device)
        
        # 计算聚合特征
        X_new = torch.tensor(new_column_features, dtype=torch.float32, device=device)
        
        # EGCN前向传播
        node_embeddings, _ = egcn_model.forward(
            node_features=features,
            X_new=X_new,
            existing_embeddings=all_column_embeddings,
            update_weights=True
        )
        
        # 使用训练好的分类器
        logits = egcn_classifier(node_embeddings)
        probabilities = F.softmax(logits, dim=1)
        predictions = torch.argmax(logits, dim=1)
        
        # 更新嵌入（除了最新的列）
        all_column_embeddings = node_embeddings[:-1] if len(all_column_features) > 0 else None
        
        # 检查最后一列（新列）的预测结果
        new_column_prediction = predictions[-1].item()
        new_column_probabilities = probabilities[-1]
        
        redundant_prob = new_column_probabilities[0].item()  # 冗余概率
        non_redundant_prob = new_column_probabilities[1].item()  # 非冗余概率
        
        # 如果预测为冗余（标签0）或者冗余概率超过阈值
        is_redundant = (new_column_prediction == 0) or (redundant_prob > REDUNDANCY_THRESHOLD)
        
        # 找到最相似的现有列（基于嵌入相似度）
        if len(all_column_features) > 0 and all_column_embeddings is not None:
            new_embedding = node_embeddings[-1].unsqueeze(0)
            existing_embeddings = node_embeddings[:-1]
            
            # 计算余弦相似度
            similarities = F.cosine_similarity(new_embedding, existing_embeddings, dim=1)
            most_similar_idx = torch.argmax(similarities).item()
            max_similarity = similarities[most_similar_idx].item()
        else:
            most_similar_idx = None
            max_similarity = 0.0
        
        return is_redundant, {
            'max_probability': redundant_prob,
            'redundant_with': most_similar_idx,
            'similarity': max_similarity,
            'non_redundant_prob': non_redundant_prob
        }

# =========================================================================
# ============= 原始代码开始（保持不变直到剪枝部分）========================
# =========================================================================

cg_st = time.time()
"""
step1: 得到一个初始解--1个计划
step2：根据初始解更新几个全局数组
step3：求解主问题--将主问题得到的对偶变量传递给子问题
step4：迭代求解子问题
    4.1 判断子问题求解完毕的reduce cost是否小于0
     4.1.1 若<=0，则更新全局数组里的信息，重新求解主问题
     4.1.2 若>0， 停止迭代
step5：求解计划生成完毕后还原0-1变量的主问题
"""

dt_all = sum(d_t[t] for t in T)

# 初始化采购量数组
total_cons_sn = np.zeros((S_num, N_num))

# 假设已经定义了 dt_all, p_n, ratio, k_s_n, S_num, N_num
total_cons_sn = np.zeros((S_num, N_num))

# 构造所有 (s, n) 对，并按性价比降序排列
index_list = [(s, n) for s in range(S_num) for n in range(N_num)]
ratio_list = [ratio[s, n] for s, n in index_list]
sorted_indices = [idx for _, idx in sorted(zip(ratio_list, index_list), key=lambda pair: -pair[0])]

remaining_demand = dt_all  # 单位：能量

for (s, n) in sorted_indices:
    if remaining_demand <= 0:
        break
    # 该供应商和煤种能提供的总能量
    available_energy = k_s_n[s, n] * p_n[n]
    if available_energy >= remaining_demand:
        # 当前对只需采购部分煤炭
        purchase = remaining_demand / p_n[n]
        total_cons_sn[s, n] = purchase
        remaining_demand = 0
    else:
        total_cons_sn[s, n] = k_s_n[s, n]
        remaining_demand -= available_energy


# 此时 total_cons_sn 即为各供应商各煤种的采购量，满足总需求 dt_all
def get_best_and_second_best_suppliers(n, ratio, S_num):
    # 提取该煤炭种类的所有供应商的性价比
    supplier_ratios = [(s, ratio[s, n]) for s in range(S_num)]

    # 按照性价比降序排列
    sorted_suppliers = sorted(supplier_ratios, key=lambda x: -x[1])

    # 获取性价比最高和次高的供应商
    best_supplier = sorted_suppliers[0][0]
    second_best_supplier = sorted_suppliers[1][0]

    return second_best_supplier


for (s, n) in sorted_indices:
    if total_cons_sn[s, n] > 2 * v:
        second_best_supplier = get_best_and_second_best_suppliers(n, ratio, S_num)

        total_cons_sn[s, n] -= v
        total_cons_sn[second_best_supplier, n] += v

berth_none = np.zeros(T_num)
for t in T:
    berth_none[t] = b

print(total_cons_sn)
alpha_op = np.zeros((S_num, N_num))
for s in S:
    for n in N:
        alpha_op[s, n] = total_cons_sn[s, n]
m = Model()
m.setParam("MIPGap", 0.79)
m.setParam("Heuristics", 1)
m.setParam("OutputFlag", 1)
alpha = m.addVars(S_num, N_num, lb=0, ub=0, vtype=GRB.CONTINUOUS)
beta = m.addVars(S_num, N_num, T_num, lb=0, ub=0, vtype=GRB.CONTINUOUS)
gamma = m.addVars(S_num, T_num, lb=0, vtype=GRB.BINARY)
miu = m.addVars(S_num, T_num, lb=0, vtype=GRB.INTEGER)
tau = m.addVars(S_num, T_num, T_num, lb=0, vtype=GRB.BINARY)
theta = m.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
rho = m.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)

for s in S:
    for t in T:
        gamma[s, t] = m.addVar(lb=0, ub=1, vtype=GRB.BINARY)
        miu[s, t] = m.addVar(lb=0, vtype=GRB.INTEGER)
        for n in N:
            beta[s, n, t] = m.addVar(lb=0, vtype=GRB.CONTINUOUS)
        for t1 in range(t):
            tau[s, t, t1] = m.addVar(lb=0, ub=0, vtype=GRB.BINARY)
        for t1 in range(t, T_num):
            tau[s, t, t1] = m.addVar(lb=0, ub=1, vtype=GRB.BINARY)
    for n in N:
        alpha[s, n] = m.addVar(lb=0, ub=k_s_n[s, n], vtype=GRB.CONTINUOUS)
for n in N:
    for t in T:
        theta[n, t] = m.addVar(lb=0, ub=q_n[n], vtype=GRB.CONTINUOUS)
        rho[n, t] = m.addVar(lb=0, ub=q_n[n], vtype=GRB.CONTINUOUS)
objective = quicksum(
    quicksum(c_s_n_coal[s, n] * alpha[s, n] for n in N) + quicksum(c_s_ship[s] * gamma[s, t] for t in T) for s in
    S)
m.setObjective(objective, GRB.MINIMIZE)

# 约束
for s in S:
    for n in N:
        m.addConstr(alpha[s, n] >= alpha_ini[s, n])
for s in S:
    for n in N:
        m.addConstr(alpha[s, n] >= quicksum(beta[s, n, t] for t in T))
for s in S:
    for t in T:
        m.addConstr(quicksum(beta[s, n, t] for n in N) <= v * gamma[s, t])
for n in N:
    m.addConstr(theta[n, 0] == l_n[n])
for n in N:
    for t in range(T_num - 1):
        m.addConstr(theta[n, t + 1] == theta[n, t] + quicksum(beta[s, n, t] for s in S) - rho[n, t])
for t in T:
    m.addConstr(quicksum(rho[n, t] * p_n[n] for n in N) == d_t[t])
for t in T:
    for n in N:
        m.addConstr(theta[n, t] >= h_n[n])
        m.addConstr(theta[n, t] <= q_n[n])
for s in S:
    for t in T:
        m.addConstr(u * (miu[s, t] - 1) <= quicksum(beta[s, n, t] for n in N))
        m.addConstr(u * miu[s, t] >= quicksum(beta[s, n, t] for n in N))
for s in S:
    for t in T:
        m.addConstr(tau[s, t, t] == gamma[s, t])
for s in S:
    for t in T:
        m.addConstr(quicksum(tau[s, t, t1] for t1 in T) >= miu[s, t])
for t in T:
    for t1 in range(t, T_num):
        for s in S:
            m.addConstr(t1 * tau[s, t, t1] <= (t + miu[s, t] - 1) * gamma[s, t])
for t1 in T:
    m.addConstr(quicksum(tau[s, t, t1] for s in S for t in T) <= b)
m.optimize()
long_time = m.objVal

# 获取初始解
alpha_op = np.zeros((S_num, N_num))
gamma_op = np.zeros((S_num, T_num))
beta_op = np.zeros((S_num, N_num, T_num))
tau_op = np.zeros((S_num, T_num, T_num))
for s in S:
    for n in N:
        alpha_op[s, n] = alpha[s, n].X
        for t in T:
            beta_op[s, n, t] = beta[s, n, t].X
    for t in T:
        gamma_op[s, t] = gamma[s, t].X
        for t1 in T:
            tau_op[s, t, t1] = tau[s, t, t1].X

print(alpha_op)
print(gamma_op)
print(beta_op)
print(tau_op)

# =========================================================================
# ============= 初始化EGCN特征库 ===========================================
# =========================================================================

print("正在为初始解提取特征...")
for s in S:
    # 提取初始列的特征
    coal_quantities = alpha_op[s, :]
    time_overlap = np.sum(tau_op[s, :, :], axis=0)
    vessel_count = np.sum(gamma_op[s, :])
    
    feature_vector = extract_column_features(coal_quantities, time_overlap, vessel_count)
    all_column_features.append(feature_vector)

print(f"已为 {len(all_column_features)} 个初始列提取特征")

# =========================================================================
# ============= 原始代码继续 ================================================
# =========================================================================

E_ogLen = S_num

E_s_dict = {s: [s] for s in S}
E_s_og = np.zeros(S_num, dtype=int)
for s in S:
    E_s_og[s] = s

c_es_s_Plan = {(e_s, s): sum(c_s_n_coal[s, n] * alpha_op[s, n] for n in N) + sum(
    c_s_ship[s] * gamma_op[s, t] for t in T) for s in S for e_s in E_s_dict[s]}


def MP(E_len, beta_mp, tau_mp, c_es_Plan_mp, E_s_dict, CorNot):
    mpst = time.time()
    pi_s_2c = np.zeros(S_num)
    pi_t1_7c = np.zeros(T_num)
    pi_n_t_4c = np.zeros((N_num, T_num - 1))
    # RLMP 启动！！！！！
    mp = Model("RLMP")
    mp.setParam("OutputFlag", 1)
    mp.setParam("MIPGap", 0)
    if CorNot == 1:
        phi = mp.addVars(E_len, S_num, lb=0, vtype=GRB.CONTINUOUS)
    else:
        phi = mp.addVars(E_len, S_num, lb=0, vtype=GRB.BINARY)
    theta = mp.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
    rho = mp.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
    mpobjective = quicksum(phi[e_s, s] * c_es_Plan_mp[e_s, s] for s in S for e_s in E_s_dict[s])
    mp.update()
    mp.setObjective(mpobjective, GRB.MINIMIZE)
    cons = {}
    cons[0] = [[] for s in S]  # phi2c
    for s in S:
        cons[0][s] = mp.addConstr(quicksum(phi[e_s, s] for e_s in E_s_dict[s]) <= 1)
    cons[1] = [[] for n in N]
    for n in N:
        cons[1][n] = mp.addConstr(theta[n, 0] == l_n[n])
    cons[2] = [[[] for t in T] for n in N]  # phi4c
    for n in N:
        for t in range(T_num - 1):
            cons[2][n][t] = mp.addConstr(theta[n, t + 1] == theta[n, t] + quicksum(
                phi[e_s, s] * beta_mp[e_s, n, t] for s in S for e_s in E_s_dict[s]) - rho[n, t])
    cons[3] = [[] for t in T]  # 5b
    for t in T:
        cons[3][t] = mp.addConstr(quicksum(p_n[n] * rho[n, t] for n in N) >= d_t[t])
    cons[4] = [[[] for t in T] for n in N]
    cons[5] = [[[] for t in T] for n in N]
    for n in N:
        for t in T:
            cons[4][n][t] = mp.addConstr(theta[n, t] <= q_n[n])
            cons[5][n][t] = mp.addConstr(theta[n, t] >= h_n[n])
    cons[6] = [[] for t1 in T]  # phi7c
    for t1 in T:
        cons[6][t1] = mp.addConstr(
            quicksum(phi[e_s, s] * tau_mp[e_s, t, t1] for t in T for s in S for e_s in E_s_dict[s]) <= b)
    mp.addConstrs(
        quicksum(beta_mp[e_s, n, t] * phi[e_s, s] for e_s in E_s_dict[s] for t in T) <= k_s_n[s, n] for s in S for n in
        N)
    mp.optimize()

    if mp.status == GRB.OPTIMAL and CorNot == 1:  # 检查优化状态
        for s in S:
            pi_s_2c[s] = cons[0][s].Pi
        for n in N:
            for t in range(T_num - 1):
                pi_n_t_4c[n, t] = cons[2][n][t].Pi
        for t1 in T:
            pi_t1_7c[t1] = cons[6][t1].Pi

    status = mp.Status
    beta_cons = np.zeros((S_num, N_num, T_num))

    for s in S:
        for n in N:
            for t in T:
                beta_cons[s, n, t] = sum(phi[e_s, s].X * beta_mp[e_s, n, t] for e_s in E_s_dict[s])
    currobj = mp.ObjVal
    return status, pi_s_2c, pi_n_t_4c, pi_t1_7c, currobj, beta_cons


def SP(pi_s_2c, pi_n_t_4c, pi_t1_7c, s_select, ban_coal_features):
    """
    修改后的定价问题，集成EGCN约束
    
    Args:
        ban_coal_features: 被禁止的特征列表（由EGCN判断的冗余列特征）
    """
    ppst = time.time()
    sp = Model("PP")
    sp.setParam("OutputFlag", 1)
    sp.setParam("MIPGap", 0)
    sp.setParam("TimeLimit", 600)
    alpha_pp = sp.addVars(N_num, lb=0, vtype=GRB.CONTINUOUS)
    beta_pp1 = sp.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
    gamma_pp = sp.addVars(T_num, lb=0, vtype=GRB.BINARY)
    miu_pp = sp.addVars(T_num, lb=0, vtype=GRB.INTEGER)
    tau_pp1 = sp.addVars(T_num, T_num, lb=0, vtype=GRB.BINARY)
    
    # =========================================================================
    # ============= 替换原始的简单剪枝约束为EGCN约束 ==========================
    # =========================================================================
    
    # 原始代码中的356-364行被替换为以下EGCN约束
    epsilon = 0.000002  # 论文中的小正数
    
    for i, banned_features in enumerate(ban_coal_features):
        if np.any(banned_features != 0):
            print(f"添加EGCN约束 {i}: 避免生成与已知冗余列相似的解")
            
            # 创建辅助变量用于绝对值约束
            coal_ban_var = sp.addVars(N_num, lb=0, vtype=GRB.CONTINUOUS)
            time_ban_var = sp.addVars(T_num, lb=0, vtype=GRB.CONTINUOUS) 
            vessel_ban_var = sp.addVar(lb=0, vtype=GRB.CONTINUOUS)
            
            # 煤炭数量约束
            for n in N:
                banned_coal = banned_features[n]
                sp.addConstr(coal_ban_var[n] >= alpha_pp[n] - banned_coal)
                sp.addConstr(coal_ban_var[n] >= -alpha_pp[n] + banned_coal)
                sp.addConstr(coal_ban_var[n] <= epsilon * max(abs(banned_coal), 1.0))
            
            # 时间重叠约束
            for t in T:
                banned_time = banned_features[N_num + t]
                time_overlap_expr = quicksum(tau_pp1[t1, t] for t1 in T)
                sp.addConstr(time_ban_var[t] >= time_overlap_expr - banned_time)
                sp.addConstr(time_ban_var[t] >= -time_overlap_expr + banned_time)
                sp.addConstr(time_ban_var[t] <= epsilon * max(abs(banned_time), 1.0))
            
            # 船只数量约束
            banned_vessel = banned_features[N_num + T_num]
            vessel_expr = quicksum(gamma_pp[t] for t in T)
            sp.addConstr(vessel_ban_var >= vessel_expr - banned_vessel)
            sp.addConstr(vessel_ban_var >= -vessel_expr + banned_vessel)
            sp.addConstr(vessel_ban_var <= epsilon * max(abs(banned_vessel), 1.0))
            
            # 总约束（论文中的约束58）
            total_diff = quicksum(coal_ban_var[n] for n in N) + \
                        quicksum(time_ban_var[t] for t in T) + \
                        vessel_ban_var
            sp.addConstr(total_diff >= epsilon)
    
    # =========================================================================
    # ============= 原始约束继续 ===============================================
    # =========================================================================
    
    for t in T:
        for t1 in range(t):
            sp.addConstr(tau_pp1[t, t1] == 0)
        for t1 in range(t, T_num):
            sp.addConstr(tau_pp1[t, t1] <= 1)

    c_es_s_PlanPP = quicksum(alpha_pp[n] * c_s_n_coal[s_select, n] for n in N) + quicksum(
        c_s_ship[s_select] * gamma_pp[t] for t in T)
    ppobjective = c_es_s_PlanPP - pi_s_2c - quicksum(
        tau_pp1[t, t1] * pi_t1_7c[t1] for t in T for t1 in T) + quicksum(
        beta_pp1[n, t] * pi_n_t_4c[n, t] for n in N for t in range(T_num - 1))
    sp.setObjective(ppobjective, GRB.MINIMIZE)
    sp.addConstrs(alpha_pp[n] <= k_s_n[s_select, n] for n in N)
    sp.addConstrs(alpha_pp[n] == quicksum(beta_pp1[n, t] for t in T) for n in N)
    sp.addConstrs(quicksum(beta_pp1[n, t] for n in N) <= v * gamma_pp[t] for t in T)
    sp.addConstrs(miu_pp[t] - 1 <= quicksum(beta_pp1[n, t] for n in N) * (1 / u) for t in T)
    sp.addConstrs(miu_pp[t] >= quicksum(beta_pp1[n, t] for n in N) * (1 / u) for t in T)
    sp.addConstrs(tau_pp1[t, t] == gamma_pp[t] for t in T)
    sp.addConstrs(quicksum(tau_pp1[t, t1] for t1 in range(t, T_num)) == miu_pp[t] for t in T)
    sp.addConstrs(t1 * tau_pp1[t, t1] <= (t + miu_pp[t] - 1) * gamma_pp[t] for t in T for t1 in range(t, T_num))
    sp.update()
    sp.optimize()
    
    c_es_PlanPP = sum(alpha_pp[n].X * c_s_n_coal[s_select, n] for n in N) + sum(
        c_s_ship[s_select] * gamma_pp[t].X for t in T)
    reduce_cost = sp.ObjVal
    beta_pp_out = np.zeros((N_num, T_num))
    tau_pp_out = np.zeros((T_num, T_num))
    
    for t in T:
        for n in N:
            beta_pp_out[n, t] = beta_pp1[n, t].X
        for t1 in T:
            tau_pp_out[t, t1] = tau_pp1[t, t1].X
    
    for n in N:
        if alpha_pp[n].X > 0:
            print(f"新一列中，从供应商{s_select} 购买{n}类煤炭的量为{alpha_pp[n].X}")
            for t in T:
                if beta_pp1[n, t].X > 0:
                    print(beta_pp1[n, t].X)
    for t in T:
        if gamma_pp[t].X > 0:
            print(f"新一列中，供应商{s_select} 船舶{gamma_pp[t].X} 在时刻{t}出发")
    
    # 提取特征
    feature_coal_quantity = np.zeros(N_num)
    feature_time_overlap = np.zeros(T_num)
    feature_vessel = 0
    for n in N:
        feature_coal_quantity[n] = sum(beta_pp_out[n, t] for t in T)
    for t in T:
        feature_time_overlap[t] = sum(tau_pp_out[t1, t] for t1 in T)
    feature_vessel = sum(gamma_pp[t].X for t in T)
    print("total_vessel", feature_vessel)
    
    return beta_pp_out, tau_pp_out, c_es_PlanPP, reduce_cost, feature_coal_quantity, feature_time_overlap, feature_vessel


# =========================================================================
# ============= 主要的CG循环（集成EGCN判断）===============================
# =========================================================================

eps = -0.001
E_len = E_ogLen
beta_mp = beta_op
tau_mp = tau_op
c_es_s_Plan_mp = c_es_s_Plan
E_s_dict_mp = E_s_dict

status, pi_s_2c_mp, pi_n_t_4c_mp, pi_t1_7c_mp, noidea, _ = MP(E_len, beta_mp, tau_mp, c_es_s_Plan_mp, E_s_dict_mp, 1)
iternum = 0
reduce_cost = np.array([0, -1, -2])

# 每个供应商的被禁特征集合（由EGCN判断的冗余列）
ban_coal_features_dict = {s: [] for s in S}

# 统计信息
total_generated_columns = 0
total_pruned_by_egcn = 0

print("=" * 60)
print("开始列生成主循环 - 集成EGCN剪枝")
print("=" * 60)

while status == GRB.OPTIMAL:
    status, pi_s_2c_mp, pi_n_t_4c_mp, pi_t1_7c_mp, currobj, cons = MP(E_len, beta_mp, tau_mp, c_es_s_Plan_mp,
                                                                      E_s_dict_mp, 1)

    if reduce_cost.sum() > eps:
        print(f"目标函数值：{currobj}")
        print("共迭代", iternum, "次")
        print(f"operatime:{time.time() - cg_st}")
        break

    reduce_cost = np.zeros(S_num)
    columns_added_this_iter = 0
    
    for s2 in S:
        beta_pp, tau_pp, c_es_PlanPP, reduce_cost[s2], feature_coal_quantity, feature_time_overlap, feature_vessel = SP(
            pi_s_2c_mp[s2], pi_n_t_4c_mp, pi_t1_7c_mp, s2, ban_coal_features_dict[s2])

        total_generated_columns += 1
        
        # 提取新列的完整特征
        new_column_features = extract_column_features(feature_coal_quantity, feature_time_overlap, feature_vessel)
        
        # =====================================================================
        # ============= 使用EGCN判断是否冗余（替换原始的欧氏距离判断）===========
        # =====================================================================
        
        print(f"\n--- 供应商 {s2} 的新列EGCN评估 ---")
        is_redundant, redundancy_info = egcn_redundancy_check(new_column_features)
        
        if is_redundant:
            print(f"EGCN判断: 冗余列 (冗余概率: {redundancy_info['max_probability']:.3f})")
            if redundancy_info['redundant_with'] is not None:
                print(f"与现有列 {redundancy_info['redundant_with']} 最相似 (相似度: {redundancy_info['similarity']:.3f})")
            print("该列被剪枝，不添加到主问题")
            
            # 将该特征添加到被禁列表，防止再次生成相似的列
            ban_coal_features_dict[s2].append(new_column_features)
            total_pruned_by_egcn += 1
            
        else:
            print(f"EGCN判断: 非冗余列 (非冗余概率: {redundancy_info['non_redundant_prob']:.3f})")
            print("该列被接受，添加到主问题")
            
            # 将新列添加到主问题
            beta_pp_expend = np.expand_dims(beta_pp, axis=0)
            beta_mp = np.concatenate((beta_mp, beta_pp_expend), axis=0)

            tau_pp_expend = np.expand_dims(tau_pp, axis=0)
            tau_mp = np.concatenate((tau_mp, tau_pp_expend), axis=0)

            c_es_s_Plan_mp[(E_len, s2)] = c_es_PlanPP
            E_s_dict_mp[s2].append(E_len)
            
            # 将特征添加到全局特征库
            all_column_features.append(new_column_features)
            
            E_len += 1
            columns_added_this_iter += 1

    iternum += 1
    
    print(f"\n迭代 {iternum} 总结:")
    print(f"  - 生成的新列: {S_num}")
    print(f"  - EGCN剪枝的列: {S_num - columns_added_this_iter}")
    print(f"  - 添加到主问题的列: {columns_added_this_iter}")
    print(f"  - 当前总列数: {E_len}")

print("=" * 60)
print("列生成算法完成")
print("=" * 60)
print(f"总计生成列数: {total_generated_columns}")
print(f"EGCN剪枝列数: {total_pruned_by_egcn}")
print(f"剪枝率: {total_pruned_by_egcn/total_generated_columns*100:.1f}%")
print(f"最终列数: {E_len}")
print(f"总运行时间: {time.time() - cg_st:.2f} 秒")

# =========================================================================
# ============= 原始代码的后续处理 ========================================
# =========================================================================

# 这里继续原始代码的后续处理逻辑...
# 包括最终解的计算、可视化等

total_cons_sn = np.zeros((S_num, N_num))
for s in S:
    for n in N:
        total_cons_sn[s, n] = sum(cons[s, n, t] for t in T)

for s in S:
    for n in N:
        if total_cons_sn[s, n] > 0:
            print("总共从供应商", s, "购买的", n, "种煤炭", total_cons_sn[s, n])

print(f"最终成本: {currobj:.2f}")
print(f"总运行时间: {time.time() - cg_st:.2f} 秒")
