from gurobipy import *
import time
import math
import numpy as np
import random
from MT_para_real import *

st = time.time()

# Create a new model
m = Model()

# Set Gurobi parameters
# m.setParam("MIPGap", 0.24)
# m.setParam("MIPGap", 0.20)
m.setParam("MIPGap", 0)
# m.setParam("TimeLimit", 300)
# m.setParam("Heuristics", 0)
m.setParam("OutputFlag", 1)

# --- Define Variables ---
alpha = m.addVars(S_num, N_num, lb=0, ub=0, vtype=GRB.CONTINUOUS)
beta = m.addVars(S_num, N_num, T_num, lb=0, ub=0, vtype=GRB.CONTINUOUS)
gamma = m.addVars(S_num, T_num, lb=0, vtype=GRB.BINARY)
miu = m.addVars(S_num, T_num, lb=0, vtype=GRB.INTEGER)
tau = m.addVars(S_num, T_num, T_num, lb=0, vtype=GRB.BINARY)
theta = m.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
rho = m.addVars(N_num, T_num, lb=0, vtype=GRB.CONTINUOUS)
phi_L = m.addVars(S_num, T_num, vtype=GRB.CONTINUOUS)

# --- Initialize Variables with specific bounds ---
for s in S:
    for t in T:
        gamma[s, t] = m.addVar(lb=0, ub=1, vtype=GRB.BINARY)
        miu[s, t] = m.addVar(lb=0, vtype=GRB.INTEGER)
        for n in N:
            beta[s, n, t] = m.addVar(lb=0, vtype=GRB.CONTINUOUS)
        for t1 in range(t):
            tau[s, t, t1] = m.addVar(lb=0, ub=0, vtype=GRB.BINARY) # Can't occupy berth before arrival
        for t1 in range(t, T_num):
            tau[s, t, t1] = m.addVar(lb=0, ub=1, vtype=GRB.BINARY)
    for n in N:
        alpha[s, n] = m.addVar(lb=0, ub=k_s_n[s, n], vtype=GRB.CONTINUOUS)

for n in N:
    for t in T:
        theta[n, t] = m.addVar(lb=0, ub=q_n[n], vtype=GRB.CONTINUOUS)
        rho[n, t] = m.addVar(lb=0, ub=q_n[n], vtype=GRB.CONTINUOUS)

# --- Define Objective Function ---
objective = quicksum(
    quicksum(c_s_n_coal[s, n] * alpha[s, n] for n in N) + quicksum(c_s_ship[s] * gamma[s, t] for t in T) for s in S
)
m.setObjective(objective, GRB.MINIMIZE)

# --- Define Constraints ---
# Constraint 2: Total purchase quantity from a supplier for a coal type cannot exceed capacity
for s in S:
    for n in N:
        m.addConstr(alpha[s, n] <= k_s_n[s, n])

# Constraint 3: Total purchase quantity must be greater than or equal to the sum of quantities shipped over time
for s in S:
    for n in N:
        m.addConstr(alpha[s, n] >= quicksum(beta[s, n, t] for t in T))

# Constraint 4: Total coal quantity on a ship cannot exceed vessel capacity
for s in S:
    for t in T:
        m.addConstr(quicksum(beta[s, n, t] for n in N) <= v * gamma[s, t])

# Constraint 5: Initial inventory level
for n in N:
    m.addConstr(theta[n, 0] == l_n[n])

# Constraint 6: Inventory balance equation
for n in N:
    for t in range(T_num - 1):
        m.addConstr(theta[n, t + 1] == theta[n, t] + quicksum(beta[s, n, t] for s in S) - rho[n, t])

# Constraint 7: Total calorific value of consumed coal must meet demand
for t in T:
    m.addConstr(quicksum(rho[n, t] * p_n[n] for n in N) == d_t[t])

# Constraint 8: Inventory levels must be within safety and capacity limits
for t in T:
    for n in N:
        m.addConstr(theta[n, t] >= h_n[n])
        m.addConstr(theta[n, t] <= q_n[n])

# Constraint 9: Relates the number of unloading operations to the quantity of coal on a ship
for s in S:
    for t in T:
        m.addConstr(u * (miu[s, t] - 1) <= quicksum(beta[s, n, t] for n in N))
        m.addConstr(u * miu[s, t] >= quicksum(beta[s, n, t] for n in N))

# Constraint 10: A ship arriving at time t occupies a berth at time t
for s in S:
    for t in T:
        m.addConstr(tau[s, t, t] == gamma[s, t])

# Constraint 11: The total time a ship occupies a berth depends on the number of unloading operations
for s in S:
    for t in T:
        m.addConstr(quicksum(tau[s, t, t1] for t1 in T) >= miu[s, t])

# Constraint 12: Berth occupation logic over time
for t in T:
    for t1 in range(t, T_num):
        for s in S:
            m.addConstr(t1 * tau[s, t, t1] <= (t - 1) * gamma[s, t] + phi_L[s, t])

# Constraint 13: Total number of berths occupied at any time cannot exceed availability
for t1 in T:
    m.addConstr(quicksum(tau[s, t, t1] for s in S for t in T) <= b)

# Linearization constraints for phi_L[s, t] = miu[s, t] * gamma[s, t]
for s in S:
    for t in T:
        m.addConstr(phi_L[s, t] <= M * gamma[s, t])
        m.addConstr(phi_L[s, t] <= miu[s, t])
        m.addConstr(phi_L[s, t] >= miu[s, t] - M * (1 - gamma[s, t]))

# --- Optimize the model ---
m.optimize()

# --- Print Results ---
print(f"Objective Value: {m.objVal}")
for s in S:
    for n in N:
        if alpha[s, n].X > 0:
            print(f"Purchased {alpha[s, n].X:.2f} tons of coal type {n} from supplier {s}, costing {alpha[s, n].X * c_s_n_coal[s, n]:.2f}")
            if n == best_n[s]:
                print(f"  This is the supplier's best type. Ratio: {alpha[s, best_n[s]].X / sum(alpha[s, n1].X for n1 in N):.2%}")
            if alpha[s, n].X >= 0.96 * k_s_n[s, n]:
                print("  Maximum available quantity was purchased.")

# if sum(gamma[s, t].x for t in T) >= 1:
#     print(
#         f"Supplier {s} dispatched {sum(gamma[s, t].x for t in T)} coal ships in total, with a shipping cost of {sum(gamma[s, t].x for t in T) * c_s_ship[s]}")

for s in S:
    for t in T:
        for n in N:
            if gamma[s, t].X > 0.1 and beta[s, n, t].X > 0:
                print(f"At time {t}, ship from supplier {s} loaded with {beta[s, n, t].X:.2f} tons of coal type {n}")

# for t in T:
#     print(f"Coal type 1, inventory at time {t} is {theta[1,t].X:.2f}")

# for s in S:
#     for t in T:
#         for t1 in T:
#             if tau[s, t, t1].X > 0.1:
#                 print(f"Ship from supplier {s}, arriving at time {t}, occupies a berth at time {t1}")

# for n in N:
#     for t in T:
#         print(f"At time {t}, the inventory for coal type {n} is {theta[n,t].x:.2f}")

# for t in T:
#     for s in S:
#         if sum(beta[s, n, t].X for n in N) > 0.1:
#             print("At time", t, "supplier", s, "supplied a total weight of",
#                   quicksum(beta[s, n, t].X for n in N), "with calorific value of",
#                   quicksum(beta[s, n, t].X * p_n[n] for n in N))

# print(f"Original Problem (OP) operation time: {time.time() - st:.4f} seconds")

total_demand = sum(d_t[t] for t in T)
for n in N:
    print(f"Total purchased amount for coal type {n}: {sum(alpha[s, n].X for s in S):.2f}")

print()
for s in S:
    print(f"Total coal cost for supplier {s}: {sum(alpha[s, n].X * c_s_n_coal[s, n] for n in N):.2f}")

print(f" Objective Value: {m.objVal:.2f}      Total Time: {time.time() - st:.4f} seconds")
